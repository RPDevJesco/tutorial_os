/*
 * boot/x86_64/entry.S - x86_64 UEFI Entry Point
 * ================================================
 *
 * CRITICAL REQUIREMENTS:
 *   1. PE/COFF entry shim for UEFI firmware (when UEFI_BOOT defined)
 *   2. Load a clean GDT (UEFI's GDT is not guaranteed after ExitBootServices)
 *   3. Reload all segment registers into a known state
 *   4. Preserve boot info pointer in RBX
 *
 * BOOT FLOW:
 * ----------
 * UEFI firmware loads us as a PE/COFF executable and calls our entry in
 * 64-bit long mode, Ring 0, paging enabled, interrupts disabled:
 *
 *   RCX = EFI_HANDLE ImageHandle     (Microsoft x64 ABI)
 *   RDX = EFI_SYSTEM_TABLE *SystemTable
 *
 * Our C stub (efi_main) handles the UEFI protocol work:
 *   - Query memory map, GOP framebuffer, ACPI RSDP
 *   - Call ExitBootServices()
 *   - Package everything into a boot_info structure
 *   - Return boot_info* in RAX
 *
 * We then load our own GDT and jump to platform_early_init.
 *
 * NOTE ON SECONDARY CORES:
 * ------------------------
 * Unlike ARM64 where all cores start executing simultaneously and must be
 * parked immediately, x86 Application Processors (APs) are held in INIT
 * state by firmware. The BSP (Bootstrap Processor) must explicitly wake
 * them later via the INIT-SIPI-SIPI IPI sequence through the local APIC.
 * No parking code is needed here - they're already parked.
 */

.section ".text.boot"
.code64


#ifdef UEFI_BOOT
/*
 * UEFI PE/COFF Entry Point
 * ========================
 * Called directly by UEFI firmware. Uses Microsoft x64 calling convention:
 *   RCX = ImageHandle, RDX = SystemTable
 *
 * The PE/COFF headers themselves are generated by the linker script and
 * objcopy (ELF → PE conversion), not hardcoded here. The linker marks
 * _efi_entry as the PE entry point.
 *
 * Only included when UEFI_BOOT is defined (native UEFI boot).
 * For custom bootloaders, skip straight to _start.
 */
.global _efi_entry
_efi_entry:
    /*
     * UEFI gives us a valid stack, so we can make function calls.
     * Forward to the C EFI stub which handles all UEFI protocol work.
     *
     * efi_main uses Microsoft x64 ABI (params in RCX, RDX).
     * It calls ExitBootServices and returns boot_info* in RAX.
     *
     * After ExitBootServices returns:
     *   - UEFI boot services are GONE (no more AllocatePool, etc.)
     *   - UEFI runtime services still available (GetTime, ResetSystem)
     *   - Memory map is frozen
     *   - We own the machine
     */
    sub     $0x28, %rsp             /* Shadow space + alignment (MS ABI) */
    call    efi_main
    add     $0x28, %rsp

    /*
     * efi_main returned boot_info* in RAX.
     * Move to RDI (System V ABI first arg) and fall through to _start.
     */
    mov     %rax, %rdi
    jmp     _real_start

.extern efi_main

#endif /* UEFI_BOOT */


/*
 * Generic entry point (non-UEFI bootloaders)
 * ===========================================
 * A custom bootloader jumps here with:
 *   RDI = pointer to boot_info structure (System V AMD64 ABI)
 *
 * The bootloader must have already:
 *   - Entered 64-bit long mode
 *   - Enabled paging (at least identity-mapped)
 *   - Disabled interrupts
 */
.global _start

#ifndef UEFI_BOOT
_start:
#endif

_real_start:
    /* Interrupts must be off during GDT/segment transition */
    cli

    /*
     * Save boot_info pointer in RBX (callee-saved register).
     * This is the x86_64 equivalent of ARM64's "mov x19, x0" - preserving
     * the bootloader's payload across our setup code.
     *
     * ARM64 preserves DTB in x19; we preserve boot_info in RBX.
     */
    mov     %rdi, %rbx


    /* =========================================================================
     * Load Our GDT
     * =========================================================================
     * After ExitBootServices, the UEFI GDT is not guaranteed to remain valid.
     * We load our own minimal 64-bit GDT to establish a clean segment state.
     *
     * This is the x86_64 equivalent of ARM64's EL3 → EL2 → EL1 transition:
     * ARM64 configures privilege levels and execution state via SCR/HCR/SPSR;
     * x86_64 configures the execution environment via the GDT and segment
     * registers. Both achieve the same goal: put the CPU in a known, clean
     * state for the kernel.
     *
     * GDT Layout:
     *   Entry 0 (0x00): Null descriptor    - required by architecture
     *   Entry 1 (0x08): 64-bit code        - CS selector = 0x08
     *   Entry 2 (0x10): 64-bit data        - DS/ES/SS selector = 0x10
     */
    lgdt    (gdt_pointer)

    /*
     * Reload CS via a far return.
     *
     * LGDT only loads the table - it doesn't reload segment registers.
     * DS/ES/SS can be reloaded with MOV, but CS requires a far jump or
     * far return because it's the code segment (you can't MOV to CS).
     *
     * We push the new CS selector and return address onto the stack,
     * then LRETQ pops both, atomically reloading CS and jumping.
     */
    pushq   $0x08                   /* New CS selector (GDT entry 1) */
    leaq    .Lreload_cs(%rip), %rax
    pushq   %rax                    /* Return address */
    lretq                           /* Far return → loads CS + jumps */

.Lreload_cs:
    /*
     * Reload data segment registers.
     * In 64-bit long mode, the CPU ignores the base/limit of DS, ES, SS
     * (they're forced to 0/max). But the selectors must still point to
     * valid GDT entries or the CPU will #GP.
     */
    mov     $0x10, %ax              /* GDT entry 2: 64-bit data */
    mov     %ax, %ds
    mov     %ax, %es
    mov     %ax, %ss

    /*
     * Zero out FS and GS.
     * These are used for thread-local storage and per-CPU data later,
     * but must be valid (null selector is fine) to avoid #GP.
     */
    xor     %ax, %ax
    mov     %ax, %fs
    mov     %ax, %gs


    /* =========================================================================
     * Jump to Platform-Specific Init
     * =========================================================================
     * RBX = boot_info pointer (preserved, callee-saved)
     *
     * platform_early_init is the x86_64 equivalent of ARM64's soc_early_init.
     * It handles platform-specific setup:
     *   - Parse ACPI tables (RSDP → RSDT/XSDT → MADT, HPET, etc.)
     *   - Detect RAM from UEFI memory map or E820
     *   - Build proper page tables (replace UEFI identity map)
     *   - Initialize the local APIC
     *   - Store detected_ram_base/detected_ram_size
     *   - Jump to boot_continue
     */
    jmp     platform_early_init


/*
 * CPU halt loop - something went terribly wrong
 */
.Lhalt:
    hlt
    jmp     .Lhalt


/* =============================================================================
 * Global Descriptor Table (GDT)
 * =============================================================================
 *
 * Minimal 64-bit GDT. In long mode, segmentation is mostly vestigial -
 * the CPU ignores base/limit for code and data segments. But the GDT
 * must still exist and segment registers must hold valid selectors.
 *
 * The important bits for each entry:
 *
 *   Code (0x08): P=1 DPL=0 S=1 Type=Execute/Read L=1 D=0
 *     L=1 (Long mode) + D=0 is REQUIRED for 64-bit code.
 *     Encoding: 0x00209A0000000000
 *       Byte 5: 0x9A = P(1) DPL(00) S(1) Type(1010 = Exec/Read)
 *       Byte 6: 0x20 = G(0) D(0) L(1) AVL(0) Limit[19:16](0)
 *
 *   Data (0x10): P=1 DPL=0 S=1 Type=Read/Write
 *     D and L bits are ignored for data segments in long mode.
 *     Encoding: 0x0000920000000000
 *       Byte 5: 0x92 = P(1) DPL(00) S(1) Type(0010 = Read/Write)
 */

.section ".data"
.align 16

gdt_table:
    .quad   0x0000000000000000      /* 0x00: Null descriptor */
    .quad   0x00209A0000000000      /* 0x08: 64-bit code (Ring 0) */
    .quad   0x0000920000000000      /* 0x10: 64-bit data (Ring 0) */
gdt_table_end:

gdt_pointer:
    .word   gdt_table_end - gdt_table - 1   /* Limit (size - 1) */
    .quad   gdt_table                        /* Base address */


/* =============================================================================
 * External Symbols
 * =============================================================================
 */
.extern platform_early_init